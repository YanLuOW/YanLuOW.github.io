<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Python格式化字符串研究"><meta name="keywords" content="Python CTF"><meta name="author" content="EVatom"><meta name="copyright" content="EVatom"><title>Python格式化字符串研究 | EVatom 's Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#本文首发于合天智汇https-mp-weixin-qq-com-s-Ww1QviZyYxnNbIil-0BW2Q"><span class="toc-number">1.</span> <span class="toc-text">本文首发于合天智汇https://mp.weixin.qq.com/s/Ww1QviZyYxnNbIil_0BW2Q</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number"></span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python3里的格式化字符串"><span class="toc-number"></span> <span class="toc-text">Python3里的格式化字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一般利用"><span class="toc-number"></span> <span class="toc-text">一般利用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Flask下读取secret-key"><span class="toc-number"></span> <span class="toc-text">Flask下读取secret_key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#django下读取SECRET-KEY"><span class="toc-number"></span> <span class="toc-text">django下读取SECRET_KEY</span></a></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="http://q2.qlogo.cn/headimg_dl?dst_uin=2466358849&amp;spec=160"></div><div class="author-info__name text-center">EVatom</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">15</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">3</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友链</div><a class="author-info-links__name text-center" href="http://hexo.imagemlt.xyz/" target="_blank" rel="noopener">Imagemlt</a><a class="author-info-links__name text-center" href="https://www.cnblogs.com/wfzWebSecuity/" target="_blank" rel="noopener">tr1ple</a><a class="author-info-links__name text-center" href="https://aryb1n.github.io/" target="_blank" rel="noopener">Aryb1n</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://images.alphacoders.com/975/975730.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">EVatom 's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">主页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a></span></div><div id="post-info"><div id="post-title">Python格式化字符串研究</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-29</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h4 id="本文首发于合天智汇https-mp-weixin-qq-com-s-Ww1QviZyYxnNbIil-0BW2Q"><a href="#本文首发于合天智汇https-mp-weixin-qq-com-s-Ww1QviZyYxnNbIil-0BW2Q" class="headerlink" title="本文首发于合天智汇https://mp.weixin.qq.com/s/Ww1QviZyYxnNbIil_0BW2Q"></a>本文首发于合天智汇<a href="https://mp.weixin.qq.com/s/Ww1QviZyYxnNbIil_0BW2Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Ww1QviZyYxnNbIil_0BW2Q</a></h4><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前两天与队友交流时提及python的格式化字符串漏洞，这个漏洞之前接触不多，所以写篇文章从基础部分仔细研究了研究。python环境是python3.7。</p>
<h2 id="Python3里的格式化字符串"><a href="#Python3里的格式化字符串" class="headerlink" title="Python3里的格式化字符串"></a>Python3里的格式化字符串</h2><p>python3中的格式化字符串主要有以下两种形式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"test %s"</span> % (<span class="string">'test'</span>)</span><br><span class="line"><span class="string">"test &#123;0&#125;"</span>.format(<span class="string">'test'</span>)</span><br></pre></td></tr></table></figure>

<p>这两个语句的输出都是test test。虽然效果一样，但是在python web的开发中一般认为前者比后者要安全，因为后者可能会因为自身支持的一些特殊用法导致配置信息等的泄露。</p>
<p>首先，format形式的格式化字符串基本用法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"I am &#123;1&#125;,he is &#123;0&#125;"</span>.format(<span class="string">"a"</span>,<span class="string">"b"</span>)</span><br></pre></td></tr></table></figure>

<p>这个语句的输出是<code>I am b,he is a</code>，大括号{}中的数字代表了format的变量顺序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;I am &#123;MyName&#125;,he is &#123;HisName&#125;&quot;.format(MyName=&quot;aa&quot;,HisName=&quot;bb&quot;)</span><br></pre></td></tr></table></figure>

<p>这个语句的输出是<code>I am aa,he is bb</code>，这种语句可以在format函数的参数通过key来赋值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"I am &#123;&#125;,he is &#123;&#125;"</span>.format(<span class="string">"a"</span>,<span class="string">"b"</span>)</span><br></pre></td></tr></table></figure>

<p>这个语句的输出是<code>I am a,he is b</code>，这样的用法会让大括号与format的参数一一对应。</p>
<p>当大括号与format的参数不能一一对应的时候便会报错，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"I am &#123;0&#125;,he is also &#123;0&#125;"</span>.format(<span class="string">'a'</span>)</span><br><span class="line"><span class="string">"I am &#123;0&#125;,he is also &#123;1&#125;"</span>.format(<span class="string">'a'</span>)</span><br></pre></td></tr></table></figure>

<p>前者会输出<code>I am a,he is also a</code>，而后者会报错<code>tuple index out of range</code>。</p>
<p>这些format函数的基本用法并不是导致格式化字符串漏洞的根源，查看下列代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"first &#123;0[1]&#125;, second &#123;0&#125;"</span>.format([<span class="string">'a'</span>,<span class="string">'b'</span>])</span><br></pre></td></tr></table></figure>

<p>输出为<code>first b, second [&#39;a&#39;, &#39;b&#39;]</code>，可见当format函数的参数是一个列表时，可以通过用方括号添加索引的方式来获取列表的值。同样的，这种用法也可以用在类的属性上，比如以下代码会输出字符串a的内置属性__class__:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"&#123;0.__class__&#125;"</span>.format(<span class="string">'a'</span>))</span><br></pre></td></tr></table></figure>

<p>输出结果是<code>&lt;class &#39;str&#39;&gt;</code></p>
<h2 id="一般利用"><a href="#一般利用" class="headerlink" title="一般利用"></a>一般利用</h2><p>python的格式化字符串的利用与沙盒逃逸或者python SSTI很相似，但format与后两者的区别在于它只能读取属性而不能执行方法，这就限制了格式化字符串的利用与攻击链的构造。举个例子，python SSTI中可以通过<code>&#39;a&#39;.__class__.__base__.__subclasses__()[12]</code>来获取任意类，但是由于format函数无法执行__subclasses__()这样的方法，直接把这种payload套进格式化字符串的利用中会报错<code>type object &#39;object&#39; has no attribute &#39;__subclasses__()&#39;</code>。</p>
<p>在与队友讨论时我们用的测试代码简化如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> secret.secret <span class="keyword">import</span> secret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppendStr</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, message = <span class="string">'test'</span>)</span>:</span></span><br><span class="line">        self.message = message</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.message</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    s = input(<span class="string">"test\n"</span>)</span><br><span class="line">    t = s + <span class="string">" by the way &#123;0&#125;"</span></span><br><span class="line">    print(t.format(AppendStr()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure>

<p>可以看到这里format函数的参数是一个对象的实例，而secret保存在全局变量中。熟悉SSTI或者沙箱绕过的都知道，python的函数类有一个内置属性__globals__可以以字典的形式返回函数所在的全局命名空间所定义的全局变量。结合format函数的格式化字符串可以读取成员属性的特性，我们很容易知道只需通过一个调用链来获取一个函数类并读取它的__globals_<em>属性即可。这里我们可以使用这样的payload：`{0.<em>_class</em></em>.<strong>init</strong>.<strong>globals</strong>}<code>。由于AppendStr类定义了\_\_init\_\_函数，所以可以通过</code>{0.<strong>class</strong>.<strong>init</strong>}<code>来获取一个函数类</code>&lt;function AppendStr.<strong>init</strong> at 0x0000019C611D2730&gt;`，再读取这个类的__globals__属性来获取secret。这个思路也适用于一切的类的成员函数，假如把测试代码改为如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    s = input(<span class="string">"test\n"</span>)</span><br><span class="line">    t = s + <span class="string">" by the way &#123;0&#125;"</span></span><br><span class="line">    print(t.format(<span class="string">'test'</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure>

<p>如果机械地套用上边的payload会报错<code>&#39;wrapper_descriptor&#39; object has no attribute &#39;__globals__&#39;</code>。可以通过以下代码来查看字符串类的成员属性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'a'</span>.__class__.__dict__)</span><br></pre></td></tr></table></figure>

<p>输出很多这里就不一一列举了。可以在输出的结果中看到字符串类并没有function类型的成员属性，所以不能通过格式化字符串来获得全局变量。</p>
<h2 id="Flask下读取secret-key"><a href="#Flask下读取secret-key" class="headerlink" title="Flask下读取secret_key"></a>Flask下读取secret_key</h2><p>把情景切换到flask下写出如下的测试代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config[<span class="string">'SECRET_KEY'</span>] = <span class="string">'gasidfjbodnjgfnof'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppendStr</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, message = <span class="string">'test'</span>)</span>:</span></span><br><span class="line">        self.message = message</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.message</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/', methods=['GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    template = <span class="string">'Hello &#123;0&#125;, This is your email: '</span> + request.args.get(<span class="string">'email'</span>)</span><br><span class="line">    <span class="keyword">return</span> template.format(AppendStr())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(<span class="string">'0.0.0.0'</span>, <span class="number">8080</span>)</span><br></pre></td></tr></table></figure>

<p>前置步骤与之前讲的相似，get方法提交参数<code>?email={0.__class__.__init__.__globals__}</code>可以看到当前的全局变量，然而secret_key并不会出现在返回中。我本地测试时返回的是这些数据：</p>
<p><img src="/2020/02/29/python%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%A0%94%E7%A9%B6/5.png" alt></p>
<p>似乎不能简单粗暴地通过这个payload来获取secret_key，我们再看看flask的代码app.py：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 部分包及代码省略</span></span><br><span class="line"><span class="keyword">from</span> .config <span class="keyword">import</span> Config, ConfigAttribute</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flask</span><span class="params">(_PackageBoundObject)</span>:</span></span><br><span class="line"><span class="comment"># 注释省略</span></span><br><span class="line">	config_class = Config</span><br><span class="line">	</span><br><span class="line">	testing = ConfigAttribute(<span class="string">'TESTING'</span>)</span><br><span class="line">	</span><br><span class="line">    secret_key = ConfigAttribute(<span class="string">'SECRET_KEY'</span>)</span><br><span class="line">    </span><br><span class="line">    session_cookie_name = ConfigAttribute(<span class="string">'SESSION_COOKIE_NAME'</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到Flask类的属性secret_key会保存当前的secret_key的值，而上边返回的全局变量里有<code>&#39;app&#39;: &lt;Flask &#39;template&#39;&gt;</code>。我这个文件名是template，这就是当前的Flask类实例化的对象。所以只需要在上边那个payload后补充一些东西就能拿到secret_key，其内容如下：<code>?email={0.__class__.__init__.__globals__[app].secret_key}</code>。</p>
<p><img src="/2020/02/29/python%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%A0%94%E7%A9%B6/6.png" alt></p>
<h2 id="django下读取SECRET-KEY"><a href="#django下读取SECRET-KEY" class="headerlink" title="django下读取SECRET_KEY"></a>django下读取SECRET_KEY</h2><p>p师傅很早以前写过一篇文章讲解过这个利用方法，其链接如下：<a href="https://www.leavesongs.com/PENETRATION/python-string-format-vulnerability.html。p师傅在文章中给出了两个payload，但并没有仔细讲解其原理。所以我这里就逐步分析下其中一个payload的构造，另一个payload思路类似。测试代码如下：" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/python-string-format-vulnerability.html。p师傅在文章中给出了两个payload，但并没有仔细讲解其原理。所以我这里就逐步分析下其中一个payload的构造，另一个payload思路类似。测试代码如下：</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    template = <span class="string">'Hello &#123;user&#125;, This is your email: '</span> + request.GET.get(<span class="string">'email'</span>)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(template.format(user=request.user))</span><br></pre></td></tr></table></figure>

<p>在未登录状态下，request.user是类AnonymousUser的实例化对象，类定义在django/contrib/auth/models.py文件中395行：</p>
<p><img src="/2020/02/29/python%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%A0%94%E7%A9%B6/1.png" alt></p>
<p>402行看到该对象的_groups属性是一个EmptyManager类的对象。429行可知该对象的groups方法也被转化为了名为groups且值与_groups相同的类属性。EmptyManager类定义在django/db/models/manager.py的195行</p>
<p><img src="/2020/02/29/python%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%A0%94%E7%A9%B6/2.png" alt></p>
<p>可以看到这个对象的model属性是与AnonymousUser类定义在同一个文件中的Group类，在django/contrib/auth/models.py文件中91行：</p>
<p><img src="/2020/02/29/python%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%A0%94%E7%A9%B6/3.png" alt></p>
<p>Group类本身定义的东西没什么好看的，一路跟随至其父类的父类ModelBase，定义在django/db/models/base.py的71行，有）：</p>
<p><img src="/2020/02/29/python%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%A0%94%E7%A9%B6/4.png" alt></p>
<p>在121行可以看到该类的_meta属性是一个Options类实例化的对象。跟踪至django/db/models/options.py的65行可以看到类定义（此处由于代码太长不截图了）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.apps <span class="keyword">import</span> apps</span><br><span class="line"><span class="comment"># 省略</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Options</span>:</span></span><br><span class="line"><span class="comment"># 省略</span></span><br><span class="line">    default_apps = apps</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, meta, app_label=None)</span>:</span></span><br><span class="line">		self.app_label = app_label</span><br><span class="line">        self.apps = self.default_apps</span><br><span class="line"><span class="comment"># 省略</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">app_config</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Don't go through get_app_config to avoid triggering imports.</span></span><br><span class="line">        <span class="keyword">return</span> self.apps.app_configs.get(self.app_label)</span><br><span class="line"><span class="comment"># 省略</span></span><br></pre></td></tr></table></figure>

<p>可以看到app_config方法被转化为了只读属性，而该属性返回<code>self.apps.app_configs.get(self.app_label)</code>。审计代码可以清楚得发现self.apps就是导入的apps模块，即一个module类的对象。跟踪至django/apps/registry.py，可以看到类Apps的定义里，即原文件13行有</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apps</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, installed_apps=<span class="params">()</span>)</span>:</span></span><br><span class="line">        self.app_configs = &#123;&#125;</span><br><span class="line"><span class="comment"># 省略</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">populate</span><span class="params">(self, installed_apps=None)</span>:</span></span><br><span class="line"><span class="comment"># 省略    </span></span><br><span class="line">            <span class="keyword">for</span> entry <span class="keyword">in</span> installed_apps:</span><br><span class="line">                <span class="keyword">if</span> isinstance(entry, AppConfig):</span><br><span class="line">                    app_config = entry</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    app_config = AppConfig.create(entry) <span class="comment"># 91行</span></span><br><span class="line">                <span class="keyword">if</span> app_config.label <span class="keyword">in</span> self.app_configs:</span><br><span class="line">                    <span class="keyword">raise</span> ImproperlyConfigured(</span><br><span class="line">                        <span class="string">"Application labels aren't unique, "</span></span><br><span class="line">                        <span class="string">"duplicates: %s"</span> % app_config.label)</span><br><span class="line"></span><br><span class="line">                self.app_configs[app_config.label] = app_config <span class="comment"># 97行</span></span><br></pre></td></tr></table></figure>

<p>跟踪91行的AppConfig.create至django/apps/config.py，有：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span>:</span></span><br><span class="line"><span class="comment"># 省略</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(cls, entry)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            module = import_module(entry)</span><br></pre></td></tr></table></figure>

<p>这个Options类实例化的对象的app_config属性返回会返回一个对象，而这个对象的module属性是python的一个模块即module。而对于我的测试代码这种情景，module的内容为<code>&lt;module &#39;django.contrib.auth&#39; from &#39;C:\\python37\\lib\\site-packages\\django\\contrib\\auth\\__init__.py&#39;&gt;</code>。查看该模块的代码，可以在文件django/contrib/auth/admin.py中看到</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="comment"># 省略</span></span><br></pre></td></tr></table></figure>

<p>settings模块里就有我们需要的SECRET_KEY。故我们可以通过简单的模块包含关系利用格式化字符串漏洞来读取SECRET_KEY，故最终payload如下：<code>[{user.groups.model._meta.app_config.module.admin.settings.SECRET_KEY}]</code></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined" target="_blank" rel="noopener">EVatom</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/02/29/python%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%A0%94%E7%A9%B6/">http://yoursite.com/2020/02/29/python%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%A0%94%E7%A9%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">EVatom 's Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Python-CTF/">Python CTF</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/03/10/XCTF%E9%AB%98%E6%A0%A1%E6%88%98%E2%80%9C%E7%96%AB%E2%80%9D%E8%B5%9Bfmkq%E5%87%BA%E9%A2%98%E7%AC%94%E8%AE%B0/"><i class="fa fa-chevron-left">  </i><span>XCTF高校战“疫”赛fmkq出题笔记</span></a></div><div class="next-post pull-right"><a href="/2020/02/26/%E5%AE%89%E6%81%92%E6%9D%AF%E6%88%98%E7%96%AB%E8%B5%9Bweb1%E9%A2%98%E8%A7%A3/"><span>安恒杯战疫赛web1题解</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://images.alphacoders.com/975/975730.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By EVatom</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>